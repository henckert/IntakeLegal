import PDFDocument from 'pdfkit';
import type { Response } from 'express';
import fs from 'fs';
import path from 'path';

// Load common disclaimer once (fallback to default string if missing)
let COMMON_DISCLAIMER = 'This content is informational only and not legal advice. Consult a qualified solicitor for specific guidance.';
try {
  const p = path.join(process.cwd(), 'server', 'knowledge', 'common', 'disclaimer.txt');
  if (fs.existsSync(p)) {
    COMMON_DISCLAIMER = fs.readFileSync(p, 'utf8').trim() || COMMON_DISCLAIMER;
  }
} catch {
  // ignore and keep default
}

export function sendIntakePDF(res: Response, data: {
  id: string;
  clientName: string;
  narrative: string;
  classification?: string;
  expiryDate?: string;
  badge?: string;
  solBasis?: string;
  solDisclaimer?: string;
  disclaimerVersion?: string;
  solVersion?: string;
  followUps?: string[];
  attachmentsOverview?: Array<{ filename: string; mimeType?: string; sizeBytes?: number; status: string; snippet?: string; truncated?: boolean; children?: Array<{ filename: string; mimeType?: string; sizeBytes?: number; status: string }>; }>;
}) {
  res.setHeader('Content-Type', 'application/pdf');
  res.setHeader('Content-Disposition', `inline; filename=intake-${data.id}.pdf`);

  const doc = new PDFDocument({ size: 'A4', margin: 56, compress: false }); // ~0.78in margin
  doc.pipe(res);
  try { doc.font('Helvetica'); } catch {}

  const preserveCursor = (fn: () => void) => {
    const x = (doc as any).x;
    const y = (doc as any).y;
    fn();
    (doc as any).x = x;
    (doc as any).y = y;
  };

  let currentPage = 1;
  const drawHeader = () => {
    const topY = 24;
    preserveCursor(() => {
      doc.save();
      doc.rect(56, topY, 28, 28).stroke('#13315C');
      doc.fontSize(12).fillColor('#0B2545').text('IntakeLegal', 90, topY + 6);
      doc.fontSize(9).fillColor('#5E6C84').text(`Reference: ${data.id}`, 90, topY + 20);
      doc.restore();
      doc.moveTo(56, topY + 36).lineTo(539, topY + 36).stroke('#E5E7EB');
    });
  };
  const drawFooter = () => {
    // Keep footer safely within printable area to avoid triggering an implicit page break
    const bottomY = 740;
    preserveCursor(() => {
      doc.save();
      doc.moveTo(56, bottomY).lineTo(539, bottomY).stroke('#E5E7EB');
      const p = `Page ${currentPage}`;
      doc.fontSize(9).fillColor('#5E6C84').text(p, 56, bottomY + 8, { width: 483, align: 'right' });
      doc.fontSize(8).fillColor('#5E6C84').text('Generated by IntakeLegal', 56, bottomY + 8, { width: 483, align: 'left' });
      doc.restore();
    });
  };
  drawHeader();
  drawFooter();
  doc.on('pageAdded', () => { currentPage += 1; drawHeader(); drawFooter(); });

  // Start body below the header line on page 1
  (doc as any).x = 56;
  (doc as any).y = Math.max((doc as any).y, 76);

  doc.moveDown().moveDown();
  doc.fontSize(20).fillColor('#101820').text('Intake Summary');
  doc.moveDown(0.5);
  doc.fontSize(11).fillColor('#101820').text(`Client: ${data.clientName}`);
  doc.fontSize(11).fillColor('#101820').text(`Classification: ${data.classification ?? '—'}`);
  if (data.expiryDate) {
    const badge = data.badge ? ` (${data.badge})` : '';
    doc.fontSize(11).text(`Limitation Expiry: ${data.expiryDate}${badge}`);
    if (data.solBasis) doc.fontSize(10).fillColor('#5E6C84').text(`${data.solBasis}`);
  }
  if (data.solDisclaimer || data.disclaimerVersion || data.solVersion) {
    const parts = [
      data.solDisclaimer,
      data.solVersion ? `SOL: ${data.solVersion}` : undefined,
      data.disclaimerVersion ? `Disclaimer v${data.disclaimerVersion}` : undefined,
    ].filter(Boolean);
    if (parts.length) {
      doc.moveDown(0.25);
      doc.fontSize(9).fillColor('#5E6C84').text(parts.join(' · '));
    }
  }

  doc.moveDown();
  doc.fontSize(14).fillColor('#101820').text('Narrative');
  doc.moveDown(0.25);
  doc.fontSize(11).fillColor('#101820').text(data.narrative || '—', { align: 'justify' });

  const fu = (data.followUps || []).slice(0, 5);
  if (fu.length) {
    doc.moveDown();
    doc.fontSize(14).fillColor('#101820').text('Follow-ups');
    doc.moveDown(0.25);
    doc.fontSize(11).fillColor('#101820');
    fu.forEach((q, idx) => doc.text(`${idx + 1}. ${q}`));
  }

  // Attachments overview section
  const ao = data.attachmentsOverview || [];
  if (ao.length) {
    doc.moveDown();
    doc.fontSize(14).fillColor('#101820').text('Attachments Reviewed');
    doc.moveDown(0.25);
    doc.fontSize(11).fillColor('#101820');
    ao.forEach((att, idx) => {
      const head = `${idx + 1}. ${att.filename} ${att.mimeType ? `(${att.mimeType})` : ''} ${typeof att.sizeBytes === 'number' ? `- ${att.sizeBytes} bytes` : ''} [${att.status}]`;
      doc.text(head);
      if (att.snippet) {
        doc.fontSize(10).fillColor('#5E6C84').text(`snippet${att.truncated ? ' (truncated)' : ''}: ${att.snippet}`);
        doc.fontSize(11).fillColor('#101820');
      }
      if (att.children && att.children.length) {
        att.children.forEach((ch, cidx) => {
          const line = `  - ${ch.filename} ${ch.mimeType ? `(${ch.mimeType})` : ''} ${typeof ch.sizeBytes === 'number' ? `- ${ch.sizeBytes} bytes` : ''} [${ch.status}]`;
          doc.text(line);
        });
      }
    });
  }

  doc.moveDown();
  doc.fontSize(12).fillColor('#101820').text('Disclaimers');
  doc.moveDown(0.25);
  doc.fontSize(10).fillColor('#101820').text(COMMON_DISCLAIMER, { align: 'justify' });

  doc.end();
}

// Generate a PDF into a Buffer for attachments (email package)
export async function generateIntakePDFBuffer(data: {
  id: string;
  clientName: string;
  narrative: string;
  classification?: string;
  expiryDate?: string;
  badge?: string;
  solBasis?: string;
  solDisclaimer?: string;
  disclaimerVersion?: string;
  solVersion?: string;
  followUps?: string[];
  attachmentsOverview?: Array<{ filename: string; mimeType?: string; sizeBytes?: number; status: string; snippet?: string; truncated?: boolean; children?: Array<{ filename: string; mimeType?: string; sizeBytes?: number; status: string }>; }>;
}): Promise<Buffer> {
  return new Promise<Buffer>((resolve) => {
    const chunks: Buffer[] = [];
    const doc = new PDFDocument({ size: 'A4', margin: 56, compress: false });
    const collect = (chunk: any) => chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
    doc.on('data', collect);
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    try { doc.font('Helvetica'); } catch {}

    const preserveCursor = (fn: () => void) => {
      const x = (doc as any).x;
      const y = (doc as any).y;
      fn();
      (doc as any).x = x;
      (doc as any).y = y;
    };

    let currentPage = 1;
    const drawHeader = () => {
      const topY = 24;
      preserveCursor(() => {
        doc.save();
        doc.rect(56, topY, 28, 28).stroke('#13315C');
        doc.fontSize(12).fillColor('#0B2545').text('IntakeLegal', 90, topY + 6);
        doc.fontSize(9).fillColor('#5E6C84').text(`Reference: ${data.id}`, 90, topY + 20);
        doc.restore();
        doc.moveTo(56, topY + 36).lineTo(539, topY + 36).stroke('#E5E7EB');
      });
    };
    const drawFooter = () => {
      // Keep footer safely within printable area to avoid triggering an implicit page break
      const bottomY = 740;
      preserveCursor(() => {
        doc.save();
        doc.moveTo(56, bottomY).lineTo(539, bottomY).stroke('#E5E7EB');
        const p = `Page ${currentPage}`;
        doc.fontSize(9).fillColor('#5E6C84').text(p, 56, bottomY + 8, { width: 483, align: 'right' });
        doc.fontSize(8).fillColor('#5E6C84').text('Generated by IntakeLegal', 56, bottomY + 8, { width: 483, align: 'left' });
        doc.restore();
      });
    };
    drawHeader();
    drawFooter();
    doc.on('pageAdded', () => { currentPage += 1; drawHeader(); drawFooter(); });

    // Start body below the header line on page 1
    (doc as any).x = 56;
    (doc as any).y = Math.max((doc as any).y, 76);

    doc.moveDown().moveDown();
    doc.fontSize(20).fillColor('#101820').text('Intake Summary');
    doc.moveDown(0.5);
    doc.fontSize(11).fillColor('#101820').text(`Client: ${data.clientName}`);
    doc.fontSize(11).fillColor('#101820').text(`Classification: ${data.classification ?? '—'}`);
    if (data.expiryDate) {
      const badge = data.badge ? ` (${data.badge})` : '';
      doc.fontSize(11).text(`Limitation Expiry: ${data.expiryDate}${badge}`);
      if (data.solBasis) doc.fontSize(10).fillColor('#5E6C84').text(`${data.solBasis}`);
    }
    if (data.solDisclaimer || data.disclaimerVersion || data.solVersion) {
      const parts = [
        data.solDisclaimer,
        data.solVersion ? `SOL: ${data.solVersion}` : undefined,
        data.disclaimerVersion ? `Disclaimer v${data.disclaimerVersion}` : undefined,
      ].filter(Boolean);
      if (parts.length) {
        doc.moveDown(0.25);
        doc.fontSize(9).fillColor('#5E6C84').text(parts.join(' · '));
      }
    }

    doc.moveDown();
    doc.fontSize(14).fillColor('#101820').text('Narrative');
    doc.moveDown(0.25);
    doc.fontSize(11).fillColor('#101820').text(data.narrative || '—', { align: 'justify' });

    const fu = (data.followUps || []).slice(0, 5);
    if (fu.length) {
      doc.moveDown();
      doc.fontSize(14).fillColor('#101820').text('Follow-ups');
      doc.moveDown(0.25);
      doc.fontSize(11).fillColor('#101820');
      fu.forEach((q, idx) => doc.text(`${idx + 1}. ${q}`));
    }

    // Attachments overview
    const ao = data.attachmentsOverview || [];
    if (ao.length) {
      doc.moveDown();
      doc.fontSize(14).fillColor('#101820').text('Attachments Reviewed');
      doc.moveDown(0.25);
      doc.fontSize(11).fillColor('#101820');
      ao.forEach((att, idx) => {
        const head = `${idx + 1}. ${att.filename} ${att.mimeType ? `(${att.mimeType})` : ''} ${typeof att.sizeBytes === 'number' ? `- ${att.sizeBytes} bytes` : ''} [${att.status}]`;
        doc.text(head);
        if (att.snippet) {
          doc.fontSize(10).fillColor('#5E6C84').text(`snippet${att.truncated ? ' (truncated)' : ''}: ${att.snippet}`);
          doc.fontSize(11).fillColor('#101820');
        }
        if (att.children && att.children.length) {
          att.children.forEach((ch, cidx) => {
            const line = `  - ${ch.filename} ${ch.mimeType ? `(${ch.mimeType})` : ''} ${typeof ch.sizeBytes === 'number' ? `- ${ch.sizeBytes} bytes` : ''} [${ch.status}]`;
            doc.text(line);
          });
        }
      });
    }

    doc.moveDown();
    doc.fontSize(12).fillColor('#101820').text('Disclaimers');
    doc.moveDown(0.25);
    doc.fontSize(10).fillColor('#101820').text(COMMON_DISCLAIMER, { align: 'justify' });

    doc.end();
  });
}
